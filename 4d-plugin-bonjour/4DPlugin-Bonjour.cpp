/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Bonjour.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Bonjour
 #	author : miyako
 #	2020/04/07
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Bonjour.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kDeinitPlugin:
                g_bonjour_delegates_clear();
                break;
                
                // --- Bonjour
                
            case 1 :
                Bonjour_Publish(params);
                break;
            case 2 :
                Bonjour_Status(params);
                break;
            case 3 :
                Bonjour_Discover(params);
                break;
            case 4 :
                Bonjour_Update(params);
                break;
            case 5 :
                Bonjour_Clear(params);
                break;
                
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

@interface Bonjour_Browser_Delegate : NSObject <NSNetServiceBrowserDelegate,NSNetServiceDelegate>
{
    Json::Value props;
    NSNetServiceBrowser *serv;
    NSMutableArray *services;
    NSTimeInterval timeout;
}
- (void)copyServiceBrowserProperties:(NSNetServiceBrowser *)service;
- (void)copyServiceBrowserErrors:(NSDictionary<NSString *,NSNumber *> *)errorDict;
- (void)start;
- (PA_ObjectRef)getProperties;
@end

@implementation Bonjour_Browser_Delegate

- (void)copyServiceBrowserProperties:(NSNetServiceBrowser *)service
{
    if(service) {
        
        BOOL includesPeerToPeer = service.includesPeerToPeer;
        
        props["includesPeerToPeer"] = includesPeerToPeer;
                
        props.removeMember("errors");
        
    }
    
}

- (void)copyServiceBrowserErrors:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    Json::Value errors = Json::Value(Json::arrayValue);
    for(NSString *key in errorDict) {
        
        if(key) {
            Json::Value error = Json::Value(Json::objectValue);
            NSNumber *errorNumber = [errorDict objectForKey:key];
            
            error["key"] = [key UTF8String];
            error["value"] = [errorNumber intValue];
            
            errors.append(error);
        }
        props["errors"] = errors;
    }

}

- (void)start {
    
    if(serv) {
        [serv setDelegate:self];
        [serv scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    }
}

- (id)initWithServiceBrowser:(NSNetServiceBrowser *)service timeout:(NSTimeInterval)interval
{
    if(!(self = [super init])) return self;
        
    serv = service;
    timeout = interval;
    
    props = Json::Value(Json::objectValue);
    
    [self copyServiceBrowserProperties:service];

    services = [[NSMutableArray alloc]init];
    
    return self;
}

- (void)dealloc
{
    if(serv) {
        [serv stop];
        [serv setDelegate:nil];
        [serv release];
        serv = nil;
    }
    
    [services release];
    services = nil;
    
    [super dealloc];
}

- (PA_ObjectRef)getProperties
{
    PA_ObjectRef properties = PA_CreateObject();
    
    ob_set_b(properties, L"includesPeerToPeer", props["includesPeerToPeer"].asBool());
    
    if(props.isMember("services")) {
        
        PA_CollectionRef services = PA_CreateCollection();
        
        Json::Value _services = props["services"];
        if (_services.isArray()) {
            for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
            {
                PA_ObjectRef service = PA_CreateObject();
                Json::Value _service = *it;
                
                if(_service.isMember("TXT")) {
                    Json::Value _TXT = _service["TXT"];
                    
                    if(_TXT.isArray()) {
                        
                        PA_ObjectRef TXT = PA_CreateObject();
                                                
                        for (Json::ValueIterator it = _TXT.begin(); it != _TXT.end(); ++it)
                        {
                            Json::Value node = *it;
                            if(node.isObject()){
                                                                
                                ob_set_s(TXT, node["key"].asCString(), node["value"].asCString());

                            }
                        }
                        ob_set_o(service, L"TXT", TXT);
                    }
                }
                
                ob_set_n(service, L"port", _service["port"].asInt());
                
                ob_set_b(service, L"includesPeerToPeer", _service["includesPeerToPeer"].asBool());
                
                ob_set_s(service, L"hostName", _service["hostName"].asCString());
                ob_set_s(service, L"type", _service["type"].asCString());
                ob_set_s(service, L"domain", _service["domain"].asCString());
                ob_set_s(service, L"name", _service["name"].asCString());
                    
                if(_service.isMember("addresses")) {
                    
                    PA_CollectionRef addresses = PA_CreateCollection();
                    
                    Json::Value _addresses = _service["addresses"];
                    if (_addresses.isArray()) {
                        for (Json::ValueIterator it = _addresses.begin(); it != _addresses.end(); ++it)
                        {
                            PA_ObjectRef address = PA_CreateObject();
                            Json::Value _address = *it;
                            
                            ob_set_s(address, L"address", _address["address"].asCString());
                            ob_set_s(address, L"version", _address["version"].asCString());
                            
                            PA_Variable v = PA_CreateVariable(eVK_Object);
                            PA_SetObjectVariable(&v, address);
                            PA_SetCollectionElement(addresses, PA_GetCollectionLength(addresses), v);
                            PA_ClearVariable(&v);
                            
                        }
                    }
                    ob_set_c(service, L"addresses", addresses);
                }
                
                PA_Variable v = PA_CreateVariable(eVK_Object);
                PA_SetObjectVariable(&v, service);
                PA_SetCollectionElement(services, PA_GetCollectionLength(services), v);
                PA_ClearVariable(&v);
                
            }
        }
        ob_set_c(properties, L"services", services);
    }
    
        
    return properties;
}

- (void)netService:(NSNetService *)sender
     didNotResolve:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    [self copyServiceBrowserErrors:errorDict];
}

- (void)netServiceWillResolve:(NSNetService *)sender
{

}

- (void)netService:(NSNetService *)service
didUpdateTXTRecordData:(NSData *)data
{
    Json::Value _services = props["services"];
        
    if (_services.isArray()) {
        
        /* can not indirectly update an array element */
        Json::Value _active_services = Json::Value(Json::arrayValue);
        
        for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
        {
            Json::Value _service = *it;
            
            std::string _name = _service["name"].asCString();
            std::string _domain = _service["domain"].asCString();
            std::string _type = _service["type"].asCString();
            
            std::string name = service.name ? std::string([service.name UTF8String]) : "";
            std::string domain = service.domain ? std::string([service.domain UTF8String]) : "";
            std::string type = service.type ? std::string([service.type UTF8String]) : "";

            if((_name == name) && (_domain == domain) && (_type == type)) {
                
                NSData *TXT = data;
                
                if(TXT) {
                    Json::Value _TXT = Json::Value(Json::arrayValue);
                    try {
                        NSDictionary<NSString *,NSData *> *TXTdict = [NSNetService dictionaryFromTXTRecordData:TXT];
                        for(NSString *key in TXTdict) {
                            
                            if(key) {
                                NSData *value = [TXTdict objectForKey:key];
                                NSString *base64 = [value base64EncodedStringWithOptions:0];
                                if(base64) {
                                    Json::Value entry = Json::Value(Json::objectValue);
                                    entry["key"] = [key UTF8String];
                                    entry["value"] = [base64 UTF8String];
                                                                        
                                    _TXT.append(entry);
                                }
                            }
                            

                        }
                        
                    }catch(...){
                        
                    }
                    
                    _service["TXT"] = _TXT;
                    
                }
                
            }
            
            _active_services.append(_service);
            
        }

        props["services"] = _active_services;
    }
    
}

- (void)netServiceDidResolveAddress:(NSNetService *)service
{
    Json::Value _services = props["services"];
        
    BOOL isNew = TRUE;
    Json::Value _service = Json::Value(Json::objectValue);
    
    if (_services.isArray()) {
        
        Json::Value _active_services = Json::Value(Json::arrayValue);
        
        for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
        {
            Json::Value __service = *it;
            
            std::string _name = __service["name"].asCString();
            std::string _domain = __service["domain"].asCString();
            std::string _type = __service["type"].asCString();
            
            std::string name = service.name ? std::string([service.name UTF8String]) : "";
            std::string domain = service.domain ? std::string([service.domain UTF8String]) : "";
            std::string type = service.type ? std::string([service.type UTF8String]) : "";

            if ((_name == name) && (_domain == domain) && (_type == type)) {
                isNew = FALSE;
                _service = __service;
                break;
            }
            
        }
        
    }
    
    NSString *name = service.name;
    NSString *domain = service.domain;
    NSString *type = service.type;
    NSString *hostName = service.hostName;
    
    NSInteger port = service.port;
    BOOL includesPeerToPeer = service.includesPeerToPeer;
    
    NSData *TXT = service.TXTRecordData;
    
    if(TXT) {
        Json::Value _TXT = Json::Value(Json::arrayValue);
        try {
            NSDictionary<NSString *,NSData *> *TXTdict = [NSNetService dictionaryFromTXTRecordData:TXT];
            for(NSString *key in TXTdict) {
                NSData *value = [TXTdict objectForKey:key];
                NSString *base64 = [value base64EncodedStringWithOptions:0];
                if(base64) {
                    Json::Value entry = Json::Value(Json::objectValue);
                    entry["key"] = [key UTF8String];
                    entry["value"] = [base64 UTF8String];
                    _TXT.append(entry);
                }
            }
            
        }catch(...){
            
        }
        
        _service["TXT"] = _TXT;
        
    }
    
    _service["name"] = name ? [name UTF8String] : "";
    _service["domain"] = domain ? [domain UTF8String] : "";
    _service["type"] = type ? [type UTF8String] : "";
    _service["hostName"] = hostName ? [hostName UTF8String] : "";
    
    _service["port"] = (int)port;
    _service["includesPeerToPeer"] = includesPeerToPeer;
                     
    NSArray<NSData *> *addresses = service.addresses;
    
    Json::Value _addresses = Json::Value(Json::arrayValue);
    
    for (NSData *address in addresses) {
            
        sockaddr *addr = (sockaddr *)[address bytes];
        
        switch(addr->sa_family) {
            case AF_INET: {
                Json::Value _address = Json::Value(Json::objectValue);
                struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
                std::vector<unsigned char> buf(INET_ADDRSTRLEN);
                inet_ntop(AF_INET, &(addr_in->sin_addr), (char *)&buf[0], INET_ADDRSTRLEN);
                std::string _addr = std::string((char *)&buf[0], INET_ADDRSTRLEN);
                _address["address"] = _addr;
                _address["version"] = "IPv4";
                _addresses.append(_address);
                break;
            }
            case AF_INET6: {
                Json::Value _address = Json::Value(Json::objectValue);
                struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
                std::vector<unsigned char> buf(INET6_ADDRSTRLEN);
                inet_ntop(AF_INET6, &(addr_in6->sin6_addr), (char *)&buf[0], INET6_ADDRSTRLEN);
                std::string _addr = std::string((char *)&buf[0], INET6_ADDRSTRLEN);
                _address["address"] = _addr;
                _address["version"] = "IPv6";
                _addresses.append(_address);
                break;
            }
            default:
                break;
        }
        
    }
    
    _service["addresses"] = _addresses;
    
    if(isNew) {
        props["services"].append(_service);
    }
    
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
           didFindService:(NSNetService *)service
               moreComing:(BOOL)moreComing
{
    if(!props.isMember("services"))
    {
        props["services"] = Json::Value(Json::arrayValue);
    }
    
    [services addObject:service];
    
    [service setDelegate:self];
    [service resolveWithTimeout:timeout];
    [service startMonitoring];
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
         didRemoveService:(NSNetService *)service
               moreComing:(BOOL)moreComing
{
    Json::Value _services = props["services"];
    if (_services.isArray()) {
        
        Json::Value _active_services = Json::Value(Json::arrayValue);
        
        for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
        {
            Json::Value _service = *it;
            
            std::string _name = _service["name"].asCString();
            std::string _domain = _service["domain"].asCString();
            std::string _type = _service["type"].asCString();
            
            std::string name = service.name ? std::string([service.name UTF8String]) : "";
            std::string domain = service.domain ? std::string([service.domain UTF8String]) : "";
            std::string type = service.type ? std::string([service.type UTF8String]) : "";

            if((_name == name) && (_domain == domain) && (_type == type)) {
                
            }else{
                _active_services.append(_service);
            }
            
        }
        props["services"] = _active_services;
    }
    
    [service stopMonitoring];
    [service setDelegate:nil];
    [services removeObjectIdenticalTo:service];
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
            didFindDomain:(NSString *)domainString
               moreComing:(BOOL)moreComing
{
    /* domain search not implemented */
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
          didRemoveDomain:(NSString *)domainString
               moreComing:(BOOL)moreComing
{
    /* domain search not implemented */
}

- (void)netServiceBrowserWillSearch:(NSNetServiceBrowser *)browser
{

}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
             didNotSearch:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    [self copyServiceBrowserErrors:errorDict];
}

- (void)netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)browser
{

}

@end

@interface Bonjour_Delegate : NSObject <NSNetServiceDelegate>
{
    Json::Value props;
    NSNetService *serv;
}
- (void)copyServiceProperties:(NSNetService *)service;
- (void)copyServiceErrors:(NSDictionary<NSString *,NSNumber *> *)errorDict;
- (void)start;
- (PA_ObjectRef)getProperties;
- (void)setTXT:(PA_ObjectRef)TXT;
@end

@implementation Bonjour_Delegate

- (void)copyServiceProperties:(NSNetService *)service
{
    if(service) {
        
        NSString *name = service.name;
        NSString *domain = service.domain;
        NSString *type = service.type;
        NSString *hostName = service.hostName;
        
        NSInteger port = service.port;
        BOOL includesPeerToPeer = service.includesPeerToPeer;
        
        props["name"] = name ? [name UTF8String] : "";
        props["domain"] = domain ? [domain UTF8String] : "";
        props["type"] = type ? [type UTF8String] : "";
        props["hostName"] = hostName ? [type UTF8String] : "";
        
        props["port"] = (int)port;
        props["includesPeerToPeer"] = includesPeerToPeer;
                     
        props.removeMember("errors");
                        
    }
    
}

- (void)copyServiceErrors:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    Json::Value errors = Json::Value(Json::arrayValue);
    for(NSString *key in errorDict) {
        
        if(key) {
            Json::Value error = Json::Value(Json::objectValue);
            NSNumber *errorNumber = [errorDict objectForKey:key];
            
            error["key"] = [key UTF8String];
            error["value"] = [errorNumber intValue];
            
            errors.append(error);
        }
        props["errors"] = errors;
    }

}

- (PA_ObjectRef)getProperties
{
    PA_ObjectRef properties = PA_CreateObject();
    
    ob_set_n(properties, L"port", props["port"].asInt());
    
    ob_set_b(properties, L"includesPeerToPeer", props["includesPeerToPeer"].asBool());
    
    ob_set_s(properties, L"hostName", props["hostName"].asCString());
    ob_set_s(properties, L"type", props["type"].asCString());
    ob_set_s(properties, L"domain", props["domain"].asCString());
    ob_set_s(properties, L"name", props["name"].asCString());
            
    if(props.isMember("errors")) {
        
        PA_CollectionRef errors = PA_CreateCollection();
        
        Json::Value _errors = props["errors"];
        if (_errors.isArray()) {
            for (Json::ValueIterator it = _errors.begin(); it != _errors.end(); ++it)
            {
                PA_ObjectRef error = PA_CreateObject();
                Json::Value _error = *it;
                
                ob_set_s(error, L"key", _error["key"].asCString());
                ob_set_n(error, L"value", _error["value"].asInt());
                
                PA_Variable v = PA_CreateVariable(eVK_Object);
                PA_SetObjectVariable(&v, error);
                PA_SetCollectionElement(errors, PA_GetCollectionLength(errors), v);
                PA_ClearVariable(&v);
                
            }
        }
        ob_set_c(properties, L"errors", errors);
    }
        
    return properties;
}

- (id)initWithService:(NSNetService *)service
{
    if(!(self = [super init])) return self;
        
    serv = service;
    
    props = Json::Value(Json::objectValue);
    
    [self copyServiceProperties:service];
    
    return self;
}

- (void)start {
    
    if(serv) {
        [serv setDelegate:self];
        [serv scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    }
}

- (void)dealloc
{
    if(serv) {
        [serv stop];
        [serv setDelegate:nil];
        [serv release];
        serv = nil;
    }
    
    [super dealloc];
}

- (void)setData:(CUTF8String)json
{
    bool parse = false;
    
    Json::Value root = Json::Value(Json::nullValue);

    Json::CharReaderBuilder builder;
    std::string errors;
    
    Json::CharReader *reader = builder.newCharReader();
    parse = reader->parse((const char *)json.c_str(),
                          (const char *)json.c_str() + json.size(),
                          &root,
                          &errors);
    delete reader;

    if (parse && root.isObject())
    {
        Json::Value::Members members = root.getMemberNames();
        NSMutableDictionary *txtDict = [[NSMutableDictionary alloc]init];
        
        for (Json::Value::Members::iterator it = members.begin() ; it != members.end(); ++it) {
            
            std::string key = *it;
            Json::Value value = root[key.c_str()];
            
            if(value.isString()) {

                NSString *_key = [[NSString alloc]initWithUTF8String:key.c_str()];
                
                if(_key) {
                    NSString *base64 = [[NSString alloc]initWithUTF8String:value.asString().c_str()];
                    if(base64) {
                        
                        
                        NSData *data = [[NSData alloc]initWithBase64EncodedString:base64 options:0];
                        
                        [txtDict setValue:data forKey:_key];
                        if(data) {
                            [data release];
                        }
                        [base64 release];
                    }
                    [_key release];
                }
 
            }
  
        }
        
        try{
            
            NSData *TXTRecordData = [NSNetService dataFromTXTRecordDictionary:txtDict];
            
            if(TXTRecordData) {
             
                BOOL success = [serv setTXTRecordData:TXTRecordData];
            }

        }catch(...){
            
        }

        [txtDict release];
        
    }

}

- (void)netServiceWillPublish:(NSNetService *)sender
{
    [self copyServiceProperties:sender];
}

- (void)netService:(NSNetService *)sender
     didNotPublish:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    [self copyServiceErrors:errorDict];
}

- (void)netServiceDidPublish:(NSNetService *)sender
{
    [self copyServiceProperties:sender];
}

- (void)netServiceWillResolve:(NSNetService *)sender
{

}

- (void)netService:(NSNetService *)sender
     didNotResolve:(NSDictionary<NSString *,NSNumber *> *)errorDict
{

}

- (void)netServiceDidResolveAddress:(NSNetService *)sender
{

}

- (void)netService:(NSNetService *)sender
didUpdateTXTRecordData:(NSData *)data
{

}

- (void)netServiceDidStop:(NSNetService *)sender
{

}

- (void)netService:(NSNetService *)sender
didAcceptConnectionWithInputStream:(NSInputStream *)inputStream
      outputStream:(NSOutputStream *)outputStream
{
    
}

@end

std::mutex g_bonjour_delegate_mutex;
std::mutex g_bonjour_browser_delegate_mutex;
std::map<uint32_t, Bonjour_Delegate *> g_bonjour_delegates;
std::map<uint32_t, Bonjour_Browser_Delegate *> g_bonjour_browser_delegates;

void g_bonjour_delegates_clear() {

    if(1) {
        
        std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
        std::map<uint32_t, Bonjour_Browser_Delegate *>::iterator it = g_bonjour_browser_delegates.begin();
        
        while (it != g_bonjour_browser_delegates.end())
        {
            Bonjour_Browser_Delegate *bonjour_delegate = it->second;
            [bonjour_delegate release];
            bonjour_delegate = nil;
            
            it++;
        }
        
         g_bonjour_browser_delegates.clear();
    }

    if(1) {
        
        std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
        std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.begin();
        
        while (it != g_bonjour_delegates.end())
        {
            Bonjour_Delegate *bonjour_delegate = it->second;
            [bonjour_delegate release];
            bonjour_delegate = nil;
            
            it++;
        }
        
        g_bonjour_delegates.clear();
    }
    
    
}

#pragma mark function to run in main process

void main_bounjour_start(Bonjour_Delegate *bonjour_delegate) {
    
    if(bonjour_delegate) {
        [bonjour_delegate start];
    }
}

void main_bounjour_browser_start(Bonjour_Browser_Delegate *bonjour_delegate) {

    if(bonjour_delegate) {
        [bonjour_delegate start];
    }
}

#pragma mark Plugin Commands

void Bonjour_Status(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());
            
            if(type == (const uint8_t *)"discover"){
                std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
                
                Bonjour_Browser_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Browser_Delegate *>::iterator it = g_bonjour_browser_delegates.find(i);
                        
                if(it != g_bonjour_browser_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    PA_ObjectRef properties = [bonjour_delegate getProperties];
                    
                    ob_set_o(status, L"properties", properties);
                    ob_set_b(status, L"success", true);

                }
            }else
            {
                std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
                
                Bonjour_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.find(i);
                        
                if(it != g_bonjour_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    PA_ObjectRef properties = [bonjour_delegate getProperties];
                    
                    ob_set_o(status, L"properties", properties);
                    ob_set_b(status, L"success", true);

                }
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Publish(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String _domain, _type, _name;
        
        ob_get_s(options, L"domain", &_domain);
        ob_get_s(options, L"type", &_type);
        ob_get_s(options, L"name", &_name);
        int port = ob_get_n(options, L"port");
        
        BOOL includesPeerToPeer = ob_get_b(options, L"includesPeerToPeer");
        
        NSString *domain = [[NSString alloc]initWithUTF8String:(const char *)_domain.c_str()];
        NSString *type = [[NSString alloc]initWithUTF8String:(const char *)_type.c_str()];
        NSString *name = [[NSString alloc]initWithUTF8String:(const char *)_name.c_str()];
        
        NSNetService *service = nil;
        
        service = [[NSNetService alloc] initWithDomain:domain
                                    type:type
                                    name:name
                                    port:port];
        
        if(service) {
            
            if(includesPeerToPeer) {
                service.includesPeerToPeer = TRUE;
            }
            
            std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
            
            uint32_t i = 1;
            
            while (g_bonjour_delegates.find(i) != g_bonjour_delegates.end()) {
                i++;
            }
            
            Bonjour_Delegate *bonjour_delegate = [[Bonjour_Delegate alloc]initWithService:service];
            
            g_bonjour_delegates.insert(std::map<uint32_t, Bonjour_Delegate *>::value_type(i, bonjour_delegate));
            
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)main_bounjour_start, bonjour_delegate);
            
            [service publish];
            
            PA_ObjectRef properties = [bonjour_delegate getProperties];
            
            ob_set_o(status, L"properties", properties);
            
            ob_set_n(status, L"id", i);
            ob_set_b(status, L"success", true);
             ob_set_s(status, L"type", "publish");
        }
        else
        {
            ob_set_s(options, L"error", "failed: NSNetService initWithDomain:type:name:port:");
        }
        
    }
 
    PA_ReturnObject(params, status);
}

void Bonjour_Discover(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String _domain, _type, _name;
        
        ob_get_s(options, L"domain", &_domain);
        ob_get_s(options, L"type", &_type);
        
        NSString *domain = [[NSString alloc]initWithUTF8String:(const char *)_domain.c_str()];
        NSString *type = [[NSString alloc]initWithUTF8String:(const char *)_type.c_str()];

        NSTimeInterval timeout = DEFAULT_RESOLVE_TIMEOUT;
        
        if(ob_is_defined(options, L"timeout")) {
            timeout = abs(ob_get_n(options, L"timeout"));
            timeout = timeout ? timeout : DEFAULT_RESOLVE_TIMEOUT;
            /* no timeout makes services sticky */
        }

        BOOL includesPeerToPeer = ob_get_b(options, L"includesPeerToPeer");
        
        NSNetServiceBrowser *browser = nil;
        
        browser = [[NSNetServiceBrowser alloc]init];
        
        if(browser) {
            
            if(includesPeerToPeer) {
                browser.includesPeerToPeer = TRUE;
            }
            
            std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
            
            uint32_t i = 1;
            
            while (g_bonjour_browser_delegates.find(i) != g_bonjour_browser_delegates.end()) {
                i++;
            }
            
            Bonjour_Browser_Delegate *bonjour_delegate = [[Bonjour_Browser_Delegate alloc]initWithServiceBrowser:browser timeout:timeout];
            
            g_bonjour_browser_delegates.insert(std::map<uint32_t, Bonjour_Browser_Delegate *>::value_type(i, bonjour_delegate));
            
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)main_bounjour_browser_start, bonjour_delegate);
            
            [browser searchForServicesOfType:type inDomain:domain];
            
            PA_ObjectRef properties = [bonjour_delegate getProperties];
            
            ob_set_o(status, L"properties", properties);
            
            ob_set_n(status, L"id", i);
            ob_set_b(status, L"success", true);
            ob_set_s(status, L"type", "discover");
            
        }
        else
        {
            ob_set_s(options, L"error", "failed: NSNetServiceBrowser init");
        }

    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Update(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());
            
            if(type == (const uint8_t *)"publish"){
                
                std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
                
                Bonjour_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.find(i);
                        
                if(it != g_bonjour_delegates.end()) {
                    bonjour_delegate = it->second;
       
                    CUTF8String data;
                    
                    if(ob_get_s(options, L"data", &data)){
                        
                        [bonjour_delegate setData:data];
                        
                        ob_set_b(status, L"success", true);
                    }
                }
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Clear(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());
            
            if(type == (const uint8_t *)"discover"){
                std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
                
                Bonjour_Browser_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Browser_Delegate *>::iterator it = g_bonjour_browser_delegates.find(i);
                        
                if(it != g_bonjour_browser_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    [bonjour_delegate release];
                    bonjour_delegate = nil;
                    
                    g_bonjour_browser_delegates.erase(it);
                    
                    ob_set_b(status, L"success", true);

                }
            }else
            {
                std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
                
                Bonjour_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.find(i);
                        
                if(it != g_bonjour_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    [bonjour_delegate release];
                    bonjour_delegate = nil;
                    
                    g_bonjour_delegates.erase(it);
                    
                    ob_set_b(status, L"success", true);

                }
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

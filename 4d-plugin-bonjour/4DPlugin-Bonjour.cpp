/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Bonjour.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Bonjour
 #	author : miyako
 #	2020/04/07
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Bonjour.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kDeinitPlugin:
                g_bonjour_delegates_clear();
                break;
                                
            case 1 :
                Bonjour_Publish(params);
                break;
            case 2 :
                Bonjour_Status(params);
                break;
            case 3 :
                Bonjour_Discover(params);
                break;
            case 4 :
                Bonjour_Update(params);
                break;
            case 5 :
                Bonjour_Clear(params);
                break;
            case 6 :
                Bonjour_Send(params);
                break;
            case 7 :
                Bonjour_Receive(params);
                break;
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

@implementation Bonjour_Browser_Delegate

//@synthesize netServiceBrowser = _netServiceBrowser;

- (void)copyServiceBrowserProperties:(NSNetServiceBrowser *)service
{
    if(service) {
        
        BOOL includesPeerToPeer = service.includesPeerToPeer;
        
        props["includesPeerToPeer"] = includesPeerToPeer;
                
        props.removeMember("errors");
        
    }
    
}

- (void)closeOutput
{
    if(outputStream) {
        [outputStream setDelegate:nil];
        [outputStream close];
        [outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [outputStream release];
    }
    
    outputStream = nil;
}

- (void)closeInput
{
    if(inputStream) {
        [inputStream setDelegate:nil];
        [inputStream close];
        [inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [inputStream release];
    }
    
    inputStream = nil;
}

- (void)close
{
    [self closeInput];
    
    [self closeOutput];
    
    props["isOpen"] = false;
}

- (void)stream:(NSStream *)stream
   handleEvent:(NSStreamEvent)event
{
    switch(event) {
            
        case NSStreamEventOpenCompleted:
                        
            break;
            
        case NSStreamEventHasBytesAvailable:;
            
            break;
            
        case NSStreamEventEndEncountered:;
            [self close];
            break;
            
        case NSStreamEventErrorOccurred:
             [self close];
            break;
            
        case NSStreamEventHasSpaceAvailable:
            if (stream == outputStream) {
                
                NSLog(@"client:write:start");
                
                NSUInteger remain = buffer.size();
                const uint8 *p = (const uint8 *)&buffer[0];
                size_t w = 0;
                
                while (remain) {
                    
                    NSInteger bytesWritten = [outputStream write:(const uint8 *)p maxLength:remain];
                    
                    if (bytesWritten > 0) {
                        
                        remain -= bytesWritten;
                        p += bytesWritten;
                        w += bytesWritten;
                        
                    } else {
                        [self close];
                    }
                    
                    break;
                }
                
                NSLog(@"client:write:total:%ld", w);
                
                buffer.resize(0);
                
                [self close];

            }
            break;
 
        case NSStreamEventNone:
            
            break;
        default:
            break;
    }
}

- (void)send:(NSData *)data toService:(NSString *)name byHost:(NSString *)hostName
{
    
    if(!(props["isOpen"].asBool())) {
        
        for(NSNetService *service in services) {
            
            if(service) {
                
                if(([service.name isEqualTo:name]) && ([service.hostName isEqualTo:hostName])) {
                    
                    buffer.resize([data length]);
                    memcpy(&buffer[0], [data bytes], [data length]);
                    
                    if([service getInputStream:&inputStream outputStream:&outputStream]) {
                        
                        if(outputStream) {
                            [outputStream setDelegate:self];
                            [outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
                            [outputStream open];
                        }
                        
                        if(inputStream) {
                            [inputStream  setDelegate:self];
                            [inputStream  scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
                            [inputStream  open];
                        }
                        
                    }else{
                        NSLog(@"failed!getInputStream:outputStream:");
                    }
                }
            }
        }
        
        props["isOpen"] = true;
    }
    
}

- (void)copyServiceBrowserErrors:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    Json::Value errors = Json::Value(Json::arrayValue);
    for(NSString *key in errorDict) {
        
        if(key) {
            Json::Value error = Json::Value(Json::objectValue);
            NSNumber *errorNumber = [errorDict objectForKey:key];
            
            error["key"] = [key UTF8String];
            error["value"] = [errorNumber intValue];
            
            errors.append(error);
        }
        props["errors"] = errors;
    }

}

- (void)start {
    
    if(!(props["isStarted"].asBool())) {
        
        inputStream = nil;
        outputStream = nil;
        
        if(netServiceBrowser) {
            [netServiceBrowser setDelegate:self];
            [netServiceBrowser scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        }
        props["isStarted"] = true;
    }

}

- (id)initWithServiceBrowser:(NSNetServiceBrowser *)service timeout:(NSTimeInterval)interval
{
    if(!(self = [super init])) return self;
        
    netServiceBrowser = [service retain];
    
    timeout = interval;
    
    props = Json::Value(Json::objectValue);
    
    props["isStarted"] = false;
    props["isOpen"] = false;
    
    [self copyServiceBrowserProperties:service];

    services = [[NSMutableArray alloc]init];
    
    return self;
}

- (void)dealloc
{
    if(netServiceBrowser) {
        [netServiceBrowser stop];
        [netServiceBrowser setDelegate:nil];
        [netServiceBrowser removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [netServiceBrowser release];
    }
    
    netServiceBrowser = nil;
    
    [services release];
    services = nil;
    
    [super dealloc];
}

- (PA_CollectionRef)getServices
{
    PA_CollectionRef services = PA_CreateCollection();
    
    if(props.isMember("services")) {

        Json::Value _services = props["services"];
        
        if (_services.isArray()) {
            for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
            {
                PA_ObjectRef service = PA_CreateObject();
                Json::Value _service = *it;
                
                if(_service.isMember("TXT")) {
                    Json::Value _TXT = _service["TXT"];
                    
                    if(_TXT.isArray()) {
                        
                        PA_ObjectRef TXT = PA_CreateObject();
                                                
                        for (Json::ValueIterator it = _TXT.begin(); it != _TXT.end(); ++it)
                        {
                            Json::Value node = *it;
                            if(node.isObject()){
                                                                
                                ob_set_s(TXT, node["key"].asCString(), node["value"].asCString());

                            }
                        }
                        ob_set_o(service, L"TXT", TXT);
                    }
                }
                
                ob_set_n(service, L"port", _service["port"].asInt());
                
                ob_set_b(service, L"includesPeerToPeer", _service["includesPeerToPeer"].asBool());
                
                ob_set_s(service, L"hostName", _service["hostName"].asCString());
                ob_set_s(service, L"type", _service["type"].asCString());
                ob_set_s(service, L"domain", _service["domain"].asCString());
                ob_set_s(service, L"name", _service["name"].asCString());
                    
                if(_service.isMember("addresses")) {
                    
                    PA_CollectionRef addresses = PA_CreateCollection();
                    
                    Json::Value _addresses = _service["addresses"];
                    if (_addresses.isArray()) {
                        for (Json::ValueIterator it = _addresses.begin(); it != _addresses.end(); ++it)
                        {
                            PA_ObjectRef address = PA_CreateObject();
                            Json::Value _address = *it;
                            
                            ob_set_s(address, L"address", _address["address"].asCString());
                            ob_set_s(address, L"version", _address["version"].asCString());
                            
                            PA_Variable v = PA_CreateVariable(eVK_Object);
                            PA_SetObjectVariable(&v, address);
                            PA_SetCollectionElement(addresses, PA_GetCollectionLength(addresses), v);
                            PA_ClearVariable(&v);
                            
                        }
                    }
                    ob_set_c(service, L"addresses", addresses);
                }
                
                PA_Variable v = PA_CreateVariable(eVK_Object);
                PA_SetObjectVariable(&v, service);
                PA_SetCollectionElement(services, PA_GetCollectionLength(services), v);
                PA_ClearVariable(&v);
                
            }
        }
        
    }
    
    return services;
}

- (PA_ObjectRef)getProperties
{
    PA_ObjectRef properties = PA_CreateObject();
    
    ob_set_b(properties, L"includesPeerToPeer", props["includesPeerToPeer"].asBool());
    
    return properties;
}

- (BOOL)isReady
{
    return !(props["isOpen"].asBool());
}

- (void)netService:(NSNetService *)sender
     didNotResolve:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    [self copyServiceBrowserErrors:errorDict];
}

- (void)netServiceWillResolve:(NSNetService *)sender
{

}

- (void)netService:(NSNetService *)service
didUpdateTXTRecordData:(NSData *)data
{
    Json::Value _services = props["services"];
        
    if (_services.isArray()) {
        
        /* can not indirectly update an array element */
        Json::Value _active_services = Json::Value(Json::arrayValue);
        
        for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
        {
            Json::Value _service = *it;
            
            std::string _name = _service["name"].asCString();
            std::string _domain = _service["domain"].asCString();
            std::string _type = _service["type"].asCString();
            
            std::string name = service.name ? std::string([service.name UTF8String]) : "";
            std::string domain = service.domain ? std::string([service.domain UTF8String]) : "";
            std::string type = service.type ? std::string([service.type UTF8String]) : "";

            if((_name == name) && (_domain == domain) && (_type == type)) {
                
                NSData *TXT = data;
                
                if(TXT) {
                    Json::Value _TXT = Json::Value(Json::arrayValue);
                    try {
                        NSDictionary<NSString *,NSData *> *TXTdict = [NSNetService dictionaryFromTXTRecordData:TXT];
                        for(NSString *key in TXTdict) {
                            
                            if(key) {
                                NSData *value = [TXTdict objectForKey:key];
                                NSString *base64 = [value base64EncodedStringWithOptions:0];
                                if(base64) {
                                    Json::Value entry = Json::Value(Json::objectValue);
                                    entry["key"] = [key UTF8String];
                                    entry["value"] = [base64 UTF8String];
                                                                        
                                    _TXT.append(entry);
                                }
                            }
                            

                        }
                        
                    }catch(...){
                        
                    }
                    
                    _service["TXT"] = _TXT;
                    
                }
                
            }
            
            _active_services.append(_service);
            
        }

        props["services"] = _active_services;
    }
    
}

- (void)netServiceDidResolveAddress:(NSNetService *)service
{
    Json::Value _services = props["services"];
        
    BOOL isNew = TRUE;
    Json::Value _service = Json::Value(Json::objectValue);
    
    if (_services.isArray()) {
        
        Json::Value _active_services = Json::Value(Json::arrayValue);
        
        for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
        {
            Json::Value __service = *it;
            
            std::string _name = __service["name"].asCString();
            std::string _domain = __service["domain"].asCString();
            std::string _type = __service["type"].asCString();
            
            std::string name = service.name ? std::string([service.name UTF8String]) : "";
            std::string domain = service.domain ? std::string([service.domain UTF8String]) : "";
            std::string type = service.type ? std::string([service.type UTF8String]) : "";

            if ((_name == name) && (_domain == domain) && (_type == type)) {
                isNew = FALSE;
                _service = __service;
                break;
            }
            
        }
        
    }
    
    NSString *name = service.name;
    NSString *domain = service.domain;
    NSString *type = service.type;
    NSString *hostName = service.hostName;
    
    NSInteger port = service.port;
    BOOL includesPeerToPeer = service.includesPeerToPeer;
    
    NSData *TXT = service.TXTRecordData;
    
    if(TXT) {
        Json::Value _TXT = Json::Value(Json::arrayValue);
        try {
            NSDictionary<NSString *,NSData *> *TXTdict = [NSNetService dictionaryFromTXTRecordData:TXT];
            for(NSString *key in TXTdict) {
                NSData *value = [TXTdict objectForKey:key];
                NSString *base64 = [value base64EncodedStringWithOptions:0];
                if(base64) {
                    Json::Value entry = Json::Value(Json::objectValue);
                    entry["key"] = [key UTF8String];
                    entry["value"] = [base64 UTF8String];
                    _TXT.append(entry);
                }
            }
            
        }catch(...){
            
        }
        
        _service["TXT"] = _TXT;
        
    }
    
    _service["name"] = name ? [name UTF8String] : "";
    _service["domain"] = domain ? [domain UTF8String] : "";
    _service["type"] = type ? [type UTF8String] : "";
    _service["hostName"] = hostName ? [hostName UTF8String] : "";
    
    _service["port"] = (int)port;
    _service["includesPeerToPeer"] = includesPeerToPeer;
                     
    NSArray<NSData *> *addresses = service.addresses;
    
    Json::Value _addresses = Json::Value(Json::arrayValue);
    
    for (NSData *address in addresses) {
            
        sockaddr *addr = (sockaddr *)[address bytes];
        
        switch(addr->sa_family) {
            case AF_INET: {
                Json::Value _address = Json::Value(Json::objectValue);
                struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
                std::vector<unsigned char> buf(INET_ADDRSTRLEN);
                inet_ntop(AF_INET, &(addr_in->sin_addr), (char *)&buf[0], INET_ADDRSTRLEN);
                std::string _addr = std::string((char *)&buf[0], INET_ADDRSTRLEN);
                _address["address"] = _addr;
                _address["version"] = "IPv4";
                _addresses.append(_address);
                break;
            }
            case AF_INET6: {
                Json::Value _address = Json::Value(Json::objectValue);
                struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
                std::vector<unsigned char> buf(INET6_ADDRSTRLEN);
                inet_ntop(AF_INET6, &(addr_in6->sin6_addr), (char *)&buf[0], INET6_ADDRSTRLEN);
                std::string _addr = std::string((char *)&buf[0], INET6_ADDRSTRLEN);
                _address["address"] = _addr;
                _address["version"] = "IPv6";
                _addresses.append(_address);
                break;
            }
            default:
                break;
        }
        
    }
    
    _service["addresses"] = _addresses;
    
    if(isNew) {
        props["services"].append(_service);
    }
    
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
           didFindService:(NSNetService *)service
               moreComing:(BOOL)moreComing
{
    if(!props.isMember("services"))
    {
        props["services"] = Json::Value(Json::arrayValue);
    }
    
    [services addObject:service];
    
    [service setDelegate:self];
    [service resolveWithTimeout:timeout];
    [service startMonitoring];
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
         didRemoveService:(NSNetService *)service
               moreComing:(BOOL)moreComing
{
    Json::Value _services = props["services"];
    if (_services.isArray()) {
        
        Json::Value _active_services = Json::Value(Json::arrayValue);
        
        for (Json::ValueIterator it = _services.begin(); it != _services.end(); ++it)
        {
            Json::Value _service = *it;
            
            std::string _name = _service["name"].asCString();
            std::string _domain = _service["domain"].asCString();
            std::string _type = _service["type"].asCString();
            
            std::string name = service.name ? std::string([service.name UTF8String]) : "";
            std::string domain = service.domain ? std::string([service.domain UTF8String]) : "";
            std::string type = service.type ? std::string([service.type UTF8String]) : "";

            if((_name == name) && (_domain == domain) && (_type == type)) {
                
            }else{
                _active_services.append(_service);
            }
            
        }
        props["services"] = _active_services;
    }
    
    [service stopMonitoring];
    [service setDelegate:nil];
    [services removeObjectIdenticalTo:service];
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
            didFindDomain:(NSString *)domainString
               moreComing:(BOOL)moreComing
{
    /* domain search not implemented */
}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
          didRemoveDomain:(NSString *)domainString
               moreComing:(BOOL)moreComing
{
    /* domain search not implemented */
}

- (void)netServiceBrowserWillSearch:(NSNetServiceBrowser *)browser
{

}

- (void)netServiceBrowser:(NSNetServiceBrowser *)browser
             didNotSearch:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    [self copyServiceBrowserErrors:errorDict];
}

- (void)netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)browser
{

}

@end

@implementation Bonjour_Delegate

- (void)copyServiceProperties:(NSNetService *)service
{
    if(service) {
        
        NSString *name = service.name;
        NSString *domain = service.domain;
        NSString *type = service.type;
        NSString *hostName = service.hostName;
        
        NSInteger port = service.port;
        BOOL includesPeerToPeer = service.includesPeerToPeer;
        
        props["name"] = name ? [name UTF8String] : "";
        props["domain"] = domain ? [domain UTF8String] : "";
        props["type"] = type ? [type UTF8String] : "";
        props["hostName"] = hostName ? [type UTF8String] : "";
        
        props["port"] = (int)port;
        props["includesPeerToPeer"] = includesPeerToPeer;
                     
        props.removeMember("errors");
                        
    }
    
}

- (void)copyServiceErrors:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    Json::Value errors = Json::Value(Json::arrayValue);
    for(NSString *key in errorDict) {
        
        if(key) {
            Json::Value error = Json::Value(Json::objectValue);
            NSNumber *errorNumber = [errorDict objectForKey:key];
            
            error["key"] = [key UTF8String];
            error["value"] = [errorNumber intValue];
            
            errors.append(error);
        }
        props["errors"] = errors;
    }

}

- (PA_ObjectRef)getProperties
{
    PA_ObjectRef properties = PA_CreateObject();
    
    ob_set_n(properties, L"port", props["port"].asInt());
    
    ob_set_b(properties, L"includesPeerToPeer", props["includesPeerToPeer"].asBool());
    
    ob_set_s(properties, L"hostName", props["hostName"].asCString());
    ob_set_s(properties, L"type", props["type"].asCString());
    ob_set_s(properties, L"domain", props["domain"].asCString());
    ob_set_s(properties, L"name", props["name"].asCString());
                
    if(props.isMember("errors")) {
        
        PA_CollectionRef errors = PA_CreateCollection();
        
        Json::Value _errors = props["errors"];
        if (_errors.isArray()) {
            for (Json::ValueIterator it = _errors.begin(); it != _errors.end(); ++it)
            {
                PA_ObjectRef error = PA_CreateObject();
                Json::Value _error = *it;
                
                ob_set_s(error, L"key", _error["key"].asCString());
                ob_set_n(error, L"value", _error["value"].asInt());
                
                PA_Variable v = PA_CreateVariable(eVK_Object);
                PA_SetObjectVariable(&v, error);
                PA_SetCollectionElement(errors, PA_GetCollectionLength(errors), v);
                PA_ClearVariable(&v);
                
            }
        }
        ob_set_c(properties, L"errors", errors);
    }
        
    return properties;
}

static void socket_callout(CFSocketRef s,
                           CFSocketCallBackType type,
                           CFDataRef address,
                           const void *data,
                           void *info) {
    
    Bonjour_Delegate *bonjour_delegate = (Bonjour_Delegate *)info;
    int fd = *(int *)data;
    
    [bonjour_delegate bind:fd];
}

- (void)bind:(int)fd
{
    CFStreamCreatePairWithSocket(kCFAllocatorDefault, fd, (CFReadStreamRef *)&inputStream, (CFWriteStreamRef *)&outputStream);
    
    if (inputStream) {
        
        [inputStream setProperty:(id)kCFBooleanTrue forKey:(NSString *)kCFStreamPropertyShouldCloseNativeSocket];
         inputStream.delegate = self;
        [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [inputStream open];
    }
            
    if(outputStream) {
        [outputStream setProperty:(id)kCFBooleanTrue forKey:(NSString *)kCFStreamPropertyShouldCloseNativeSocket];
         outputStream.delegate = self;
        [outputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [outputStream open];
    }
     
    if (!inputStream && !outputStream) {
        close(fd);
    }
    
}

- (id)initWithService:(NSNetService *)service
{
    if(!(self = [super init])) return self;
        
    netService = [service retain];
    
    props = Json::Value(Json::objectValue);
    
    props["isReady"] = false;
    props["isStarted"] = false;
    props["isPublished"] = false;
    
    [self copyServiceProperties:netService];
    
    return self;
}

- (void)start {
    
#if CREATE_CONNECTION_STREAM
    
    if(!(props["isReady"].asBool())) {
        
            CFSocketContext context = {0, self, NULL, NULL, NULL};

            _ipv4socket = CFSocketCreate(kCFAllocatorDefault, AF_INET,  SOCK_STREAM, 0, kCFSocketAcceptCallBack, socket_callout, &context);
            _ipv6socket = CFSocketCreate(kCFAllocatorDefault, AF_INET6, SOCK_STREAM, 0, kCFSocketAcceptCallBack, socket_callout, &context);
            
            static const int reuse = true;
            
            if(_ipv4socket) {
                if(!setsockopt(CFSocketGetNative(_ipv4socket), SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse, sizeof(reuse))) {
                    
                    struct sockaddr_in addr;
                    memset(&addr, 0, sizeof(addr));
                    
                    addr.sin_len = sizeof(addr);
                    addr.sin_family = AF_INET;
                    addr.sin_addr.s_addr = htonl(INADDR_ANY);
                    addr.sin_port = htons(netService.port);
                    
                    CFDataRef addressData = CFDataCreate(NULL, (const UInt8 *)&addr, sizeof(addr));
                    
                    if (CFSocketSetAddress(_ipv4socket, addressData) == kCFSocketSuccess)
                    {
                        _rls_ipv4socket = CFSocketCreateRunLoopSource(kCFAllocatorDefault, _ipv4socket, 0);
                        CFRunLoopAddSource(CFRunLoopGetCurrent(), _rls_ipv4socket, kCFRunLoopCommonModes);
                        
                        props["isReady"] = true;
                    }
                    
                    CFRelease(addressData);
                }
            }
            
            if(_ipv6socket) {
                if(!setsockopt(CFSocketGetNative(_ipv6socket), SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse, sizeof(reuse))) {
                    
                    struct sockaddr_in6 addr;
                    memset(&addr, 0, sizeof(addr));
                    
                    addr.sin6_len = sizeof(addr);
                    addr.sin6_family = AF_INET6;
                    memcpy(&(addr.sin6_addr), &in6addr_any, sizeof(addr.sin6_addr));
                    addr.sin6_port = htons(netService.port);
                                
                    CFDataRef addressData = CFDataCreate(NULL, (const UInt8 *)&addr, sizeof(addr));
                    
                    if (CFSocketSetAddress(_ipv6socket, addressData) == kCFSocketSuccess)
                    {
                        _rls_ipv6socket = CFSocketCreateRunLoopSource(kCFAllocatorDefault, _ipv6socket, 0);
                        CFRunLoopAddSource(CFRunLoopGetCurrent(), _rls_ipv6socket, kCFRunLoopCommonModes);
                                        
                        props["isReady"] = true;
                    }
                    
                    CFRelease(addressData);
                }
            }
        }
#else
    props["isReady"] = true;
#endif
        
    if(props["isReady"].asBool()) {
    
        if(!(props["isStarted"].asBool())) {
            
            inputStream = nil;
            outputStream = nil;
            
            [netService setDelegate:self];
            [netService scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
            
#if CREATE_CONNECTION_STREAM
            [netService publishWithOptions:NSNetServiceNoAutoRename];
#else
            [netService publishWithOptions:NSNetServiceListenForConnections|NSNetServiceNoAutoRename];
#endif

        }
  
    }
         
}

- (void)closeInput
{
    if(inputStream) {
        [inputStream setDelegate:nil];
        [inputStream close];
        [inputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [inputStream release];
    }
    
    inputStream = nil;
}

- (void)closeOutput
{
    if(outputStream) {
        [outputStream setDelegate:nil];
        [outputStream close];
        [outputStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
        [outputStream release];
    }
    
    outputStream = nil;
}

- (void)close
{
    [self closeInput];
    [self closeOutput];
}

- (void)dealloc
{
    [self close];
    
    [netService stop];
    [netService setDelegate:nil];
    [netService removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
    [netService release];
    
    netService = nil;
        
    if(_ipv4socket) {
        CFRunLoopRemoveSource(CFRunLoopGetCurrent(), _rls_ipv4socket, kCFRunLoopCommonModes);
        CFRelease(_rls_ipv4socket);
        CFSocketInvalidate(_ipv4socket);
        CFRelease(_ipv4socket);
    }
    
    _ipv4socket = nil;
    
    if(_ipv6socket) {
        CFRunLoopRemoveSource(CFRunLoopGetCurrent(), _rls_ipv6socket, kCFRunLoopCommonModes);
        CFRelease(_rls_ipv6socket);
        CFSocketInvalidate(_ipv6socket);
        CFRelease(_ipv6socket);
    }
    
    _ipv6socket = nil;
    
    [super dealloc];
}


- (NSData *)getData:(size_t *)remaining
{
    NSData *data = nil;
    
    size_t _remaining = buffers.size();
    
    if(buffers.size()) {

        std::vector< std::vector<unsigned char> >::iterator it = buffers.begin();
                
        std::vector<unsigned char> buffer = *it;
        
        data = [[NSData alloc]initWithBytes:buffer.data() length:buffer.size()];
        
        buffers.erase(it);
    }
    
    *remaining = _remaining;
    
    return data;
}

- (BOOL)setData:(CUTF8String)json
{
    BOOL success = FALSE;
    
    bool parse = false;
    
    Json::Value root = Json::Value(Json::nullValue);

    Json::CharReaderBuilder builder;
    std::string errors;
    
    Json::CharReader *reader = builder.newCharReader();
    parse = reader->parse((const char *)json.c_str(),
                          (const char *)json.c_str() + json.size(),
                          &root,
                          &errors);
    delete reader;

    if (parse && root.isObject())
    {
        Json::Value::Members members = root.getMemberNames();
        NSMutableDictionary *txtDict = [[NSMutableDictionary alloc]init];
        
        for (Json::Value::Members::iterator it = members.begin() ; it != members.end(); ++it) {
            
            std::string key = *it;
            Json::Value value = root[key.c_str()];
            
            if(value.isString()) {

                NSString *_key = [[NSString alloc]initWithUTF8String:key.c_str()];
                
                if(_key) {
                    NSString *base64 = [[NSString alloc]initWithUTF8String:value.asString().c_str()];
                    if(base64) {
                        
                        
                        NSData *data = [[NSData alloc]initWithBase64EncodedString:base64 options:0];
                        
                        [txtDict setValue:data forKey:_key];
                        if(data) {
                            [data release];
                        }
                        [base64 release];
                    }
                    [_key release];
                }
 
            }
  
        }
        
        try{
            
            NSData *TXTRecordData = [NSNetService dataFromTXTRecordDictionary:txtDict];
            
            if(TXTRecordData) {
             
                success = [netService setTXTRecordData:TXTRecordData];
            }

        }catch(...){
            
        }

        [txtDict release];
        
    }

    return success;
}

#pragma mark NSNetServiceDelegate

- (void)netServiceWillPublish:(NSNetService *)sender
{
    [self copyServiceProperties:sender];
}

- (void)netService:(NSNetService *)sender
     didNotPublish:(NSDictionary<NSString *,NSNumber *> *)errorDict
{
    [self copyServiceErrors:errorDict];
}

- (void)netServiceDidPublish:(NSNetService *)sender
{
    props["isPublished"] = true;
    
    [self copyServiceProperties:sender];
}

/*
 
 - (void)netServiceWillResolve:(NSNetService *)sender
 {

 }

 - (void)netService:(NSNetService *)sender
      didNotResolve:(NSDictionary<NSString *,NSNumber *> *)errorDict
 {

 }

 - (void)netServiceDidResolveAddress:(NSNetService *)sender
 {

 }

 - (void)netService:(NSNetService *)sender
 didUpdateTXTRecordData:(NSData *)data
 {

 }
 
 */

- (void)netServiceDidStop:(NSNetService *)sender
{
    props["isPublished"] = false;
    
    [self copyServiceProperties:sender];
}

#if !CREATE_CONNECTION_STREAM

- (void)netService:(NSNetService *)sender
didAcceptConnectionWithInputStream:(NSInputStream *)inputStream
      outputStream:(NSOutputStream *)outputStream 
{

}

#endif

#pragma mark NSStreamDelegate

- (void)stream:(NSStream *)stream
   handleEvent:(NSStreamEvent)event
{
    
    switch(event) {
            
        case NSStreamEventOpenCompleted:
                        
            break;
            
        case NSStreamEventHasBytesAvailable:
            
            if(stream == inputStream) {
                
                if(buffers.size() < BUFFER_MAX_SIZE) {

                    NSLog(@"server:read:start");
                    
                    std::vector<unsigned char> buffer;
                    UInt8 buf[BUFFER_BLOCK_SIZE];
                    
                    while (1) {

                        NSInteger bytesRead = [inputStream read:buf maxLength:BUFFER_BLOCK_SIZE];

                        if (bytesRead > 0) {
                            
                            size_t p = buffer.size();
                            buffer.resize(p + bytesRead);
                            memcpy(&buffer[p], buf, bytesRead);
                            
                        } else {
                            if(bytesRead == 0) {
                                
                                buffers.push_back(buffer);
                                
                                NSLog(@"server:read:total:%ld", buffer.size());
                            }
                            break;
                        }

                    }

                }
                
            }

            break;
            
        case NSStreamEventEndEncountered:
            [self close];
            break;
            
        case NSStreamEventHasSpaceAvailable:
            
            break;
        case NSStreamEventErrorOccurred:
            [self close];
            break;

        case NSStreamEventNone:
            
            break;
            
        default:
            break;
    }
}

@end

std::mutex g_bonjour_delegate_mutex;
std::mutex g_bonjour_browser_delegate_mutex;
std::map<uint32_t, Bonjour_Delegate *> g_bonjour_delegates;
std::map<uint32_t, Bonjour_Browser_Delegate *> g_bonjour_browser_delegates;

void g_bonjour_delegates_clear() {

    if(1) {
        
        std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
        std::map<uint32_t, Bonjour_Browser_Delegate *>::iterator it = g_bonjour_browser_delegates.begin();
        
        while (it != g_bonjour_browser_delegates.end())
        {
            Bonjour_Browser_Delegate *bonjour_delegate = it->second;
            [bonjour_delegate release];
            bonjour_delegate = nil;
            
            it++;
        }
        
         g_bonjour_browser_delegates.clear();
    }

    if(1) {
        
        std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
        std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.begin();
        
        while (it != g_bonjour_delegates.end())
        {
            Bonjour_Delegate *bonjour_delegate = it->second;
            [bonjour_delegate release];
            bonjour_delegate = nil;
            
            it++;
        }
        
        g_bonjour_delegates.clear();
    }
    
    
}

typedef struct {
    
    Bonjour_Browser_Delegate *bonjour_delegate;
    NSString *name;
    NSString *hostName;
    NSData *data;
    
}bounjour_browser_send_ctx_t;

#pragma mark PA_RunInMainProcess

void main_bounjour_start(Bonjour_Delegate *bonjour_delegate) {
    
    if(bonjour_delegate) {
        [bonjour_delegate start];
    }
}

void main_bounjour_browser_start(Bonjour_Browser_Delegate *bonjour_delegate) {

    if(bonjour_delegate) {
        [bonjour_delegate start];
    }
}

void main_bounjour_browser_send(bounjour_browser_send_ctx_t *ctx) {

    if(ctx) {
        [ctx->bonjour_delegate send:ctx->data toService:ctx->name byHost:ctx->hostName];
    }

}

#pragma mark Plugin Commands

void Bonjour_Status(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());
            
            if(type == (const uint8_t *)"discover"){
                std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
                
                Bonjour_Browser_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Browser_Delegate *>::iterator it = g_bonjour_browser_delegates.find(i);
                        
                if(it != g_bonjour_browser_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    PA_ObjectRef properties = [bonjour_delegate getProperties];
                    PA_CollectionRef services = [bonjour_delegate getServices];
                    
                    ob_set_c(status, L"services", services);
                    ob_set_o(status, L"properties", properties);
                    ob_set_b(status, L"success", true);

                }
            }else
            {
                std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
                
                Bonjour_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.find(i);
                        
                if(it != g_bonjour_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    PA_ObjectRef properties = [bonjour_delegate getProperties];
                    
                    ob_set_o(status, L"properties", properties);
                    ob_set_b(status, L"success", true);

                }
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Publish(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String _domain, _type, _name;
        
        ob_get_s(options, L"domain", &_domain);
        ob_get_s(options, L"type", &_type);
        ob_get_s(options, L"name", &_name);
        int port = ob_get_n(options, L"port");
        
        BOOL includesPeerToPeer = ob_get_b(options, L"includesPeerToPeer");
        
        NSString *domain = [[NSString alloc]initWithUTF8String:(const char *)_domain.c_str()];
        NSString *type = [[NSString alloc]initWithUTF8String:(const char *)_type.c_str()];
        NSString *name = [[NSString alloc]initWithUTF8String:(const char *)_name.c_str()];
        
        NSNetService *service = nil;
        
        service = [[NSNetService alloc] initWithDomain:domain
                                    type:type
                                    name:name
                                    port:port];
        
        if(service) {
            
            if(includesPeerToPeer) {
                service.includesPeerToPeer = TRUE;
            }
            
            std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
            
            uint32_t i = 1;
            
            while (g_bonjour_delegates.find(i) != g_bonjour_delegates.end()) {
                i++;
            }
            
            Bonjour_Delegate *bonjour_delegate = [[Bonjour_Delegate alloc]initWithService:service];
            
            [service release];
            
            g_bonjour_delegates.insert(std::map<uint32_t, Bonjour_Delegate *>::value_type(i, bonjour_delegate));
            
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)main_bounjour_start, bonjour_delegate);
                        
            PA_ObjectRef properties = [bonjour_delegate getProperties];
            ob_set_o(status, L"properties", properties);
            
            ob_set_n(status, L"id", i);
            ob_set_b(status, L"success", true);
             ob_set_s(status, L"type", "publish");
        }
        else
        {
            ob_set_s(options, L"error", "failed: NSNetService initWithDomain:type:name:port:");
        }
        
    }
 
    PA_ReturnObject(params, status);
}

void Bonjour_Discover(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String _domain, _type, _name;
        
        ob_get_s(options, L"domain", &_domain);
        ob_get_s(options, L"type", &_type);
        
        NSString *domain = [[NSString alloc]initWithUTF8String:(const char *)_domain.c_str()];
        NSString *type = [[NSString alloc]initWithUTF8String:(const char *)_type.c_str()];

        NSTimeInterval timeout = DEFAULT_RESOLVE_TIMEOUT;
        
        if(ob_is_defined(options, L"timeout")) {
            timeout = abs(ob_get_n(options, L"timeout"));
            timeout = timeout ? timeout : DEFAULT_RESOLVE_TIMEOUT;
            /* no timeout makes services sticky */
        }

        BOOL includesPeerToPeer = ob_get_b(options, L"includesPeerToPeer");
        
        NSNetServiceBrowser *browser = nil;
        
        browser = [[NSNetServiceBrowser alloc]init];
        
        if(browser) {
            
            if(includesPeerToPeer) {
                browser.includesPeerToPeer = TRUE;
            }
            
            std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
            
            uint32_t i = 1;
            
            while (g_bonjour_browser_delegates.find(i) != g_bonjour_browser_delegates.end()) {
                i++;
            }
            
            Bonjour_Browser_Delegate *bonjour_delegate = [[Bonjour_Browser_Delegate alloc]initWithServiceBrowser:browser timeout:timeout];
            
            [browser release];
            
            g_bonjour_browser_delegates.insert(std::map<uint32_t, Bonjour_Browser_Delegate *>::value_type(i, bonjour_delegate));
            
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)main_bounjour_browser_start, bonjour_delegate);
            
            [browser searchForServicesOfType:type inDomain:domain];
            
            PA_ObjectRef properties = [bonjour_delegate getProperties];
            PA_CollectionRef services = [bonjour_delegate getServices];
            
            ob_set_o(status, L"properties", properties);
            ob_set_c(status, L"services", services);
            ob_set_n(status, L"id", i);
            ob_set_b(status, L"success", true);
            ob_set_s(status, L"type", "discover");
            
        }
        else
        {
            ob_set_s(options, L"error", "failed: NSNetServiceBrowser init");
        }

    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Update(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());
            
            if(type == (const uint8_t *)"publish"){
                
                std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
                
                Bonjour_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.find(i);
                        
                if(it != g_bonjour_delegates.end()) {
                    bonjour_delegate = it->second;
       
                    CUTF8String data;
                    
                    if(ob_get_s(options, L"data", &data)){
                        
                        ob_set_b(status, L"success", [bonjour_delegate setData:data]);
                    }
                }
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Clear(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());
            
            if(type == (const uint8_t *)"discover"){
                std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
                
                Bonjour_Browser_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Browser_Delegate *>::iterator it = g_bonjour_browser_delegates.find(i);
                        
                if(it != g_bonjour_browser_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    [bonjour_delegate release];
                    bonjour_delegate = nil;
                    
                    g_bonjour_browser_delegates.erase(it);
                    
                    ob_set_b(status, L"success", true);

                }
            }else
            {
                std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
                
                Bonjour_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.find(i);
                        
                if(it != g_bonjour_delegates.end()) {
                    bonjour_delegate = it->second;
                    
                    [bonjour_delegate release];
                    bonjour_delegate = nil;
                    
                    g_bonjour_delegates.erase(it);
                    
                    ob_set_b(status, L"success", true);

                }
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Send(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());
            
            if(type == (const uint8_t *)"discover"){
                
                PA_ObjectRef service = ob_get_o(options, L"service");
                
                if(service) {
                
                    CUTF8String _name, _hostName;
                                        
                    if(ob_get_s(service, L"hostName", &_hostName)){
                        if(ob_get_s(service, L"name", &_name)){
                          NSString *name = [[NSString alloc]initWithUTF8String:(const char *)_name.data()];
                            if(name) {
                                NSString *hostName = [[NSString alloc]initWithUTF8String:(const char *)_hostName.data()];
                                if(hostName) {
                                 
                                    std::lock_guard<std::mutex> lock(g_bonjour_browser_delegate_mutex);
                                                                        
                                    Bonjour_Browser_Delegate *bonjour_delegate = NULL;
                                    
                                    std::map<uint32_t, Bonjour_Browser_Delegate *>::iterator it = g_bonjour_browser_delegates.find(i);
                                            
                                    if(it != g_bonjour_browser_delegates.end()) {
                                        
                                        bonjour_delegate = it->second;
                                        
                                        if([bonjour_delegate isReady]) {
                                            
                                            std::vector<unsigned char>buf;

                                            size_t len = (size_t)PA_GetBlobParameter(params, 2, 0L);
                                            
                                            if(len) {
                                                
                                                buf.resize(len);
                                                PA_GetBlobParameter(params, 2, &buf[0]);
                                                
                                                NSData *data = [[NSData alloc]initWithBytes:buf.data() length:buf.size()];
                                                
                                                if(data) {
                                                    
                                                    bounjour_browser_send_ctx_t ctx;
                                                    
                                                    ctx.name = name;
                                                    ctx.hostName = hostName;
                                                    ctx.data = data;
                                                    ctx.bonjour_delegate = bonjour_delegate;
                                                
                                                    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)main_bounjour_browser_send, &ctx);
                                                    
                                                    ob_set_b(status, L"success", true);
                                                    
                                                    [data release];
                                                }
                                            }
                                        }
                                    }
                                    
                                    [hostName release];
                                }
                                
                                [name release];
                            }
                        }
                    }
                }
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void Bonjour_Receive(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    ob_set_b(status, L"success", false);
    
    if(options){
        
        CUTF8String type;
        
        if(ob_get_s(options, L"type", &type)){
            
            uint32_t i = ob_get_n(options, L"id");
            
            ob_set_n(status, L"id", i);
            ob_set_s(status, L"type", (const char *)type.c_str());

            if(type == (const uint8_t *)"publish"){
                
                std::lock_guard<std::mutex> lock(g_bonjour_delegate_mutex);
                
                Bonjour_Delegate *bonjour_delegate = NULL;
                
                std::map<uint32_t, Bonjour_Delegate *>::iterator it = g_bonjour_delegates.find(i);
                        
                if(it != g_bonjour_delegates.end()) {
                    
                    bonjour_delegate = it->second;
                    
                    size_t remaining = 0;
                    
                    NSData *data = [bonjour_delegate getData:&remaining];

                    if(data) {
                        
                        PA_SetBlobParameter(params, 2, (void *)[data bytes], (PA_long32)[data length]);

                        [data release];
                        
                    }else{
                        PA_SetBlobParameter(params, 2, (void *)"", (PA_long32)0L);
                    }
                    
                    ob_set_n(status, L"remaining", remaining);
                    ob_set_b(status, L"success", true);
    
                }
            }
        }
    }
    
     PA_ReturnObject(params, status);
}
